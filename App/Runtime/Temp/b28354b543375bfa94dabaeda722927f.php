<?php
//000000086400a:5:{i:0;a:8:{s:2:"id";s:2:"60";s:5:"title";s:28:"常见的HTTP状态码拆解";s:7:"content";s:7879:"<h2 data-line="0" class="line" style="line-height: 2em;">HTTP状态码</h2><p style="line-height: 1.75em;">状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p><ul class=" list-paddingleft-2"><ul style="list-style-type: square;" class=" list-paddingleft-2"><li><p style="line-height: 1.75em;">1xx：指示信息–表示请求已接收，继续处理</p></li><li><p style="line-height: 1.75em;">2xx：成功–表示请求已被成功接收、理解、接受</p></li><li><p style="line-height: 1.75em;">3xx：重定向–要完成请求必须进行更进一步的操作</p></li><li><p style="line-height: 1.75em;">4xx：客户端错误–请求有语法错误或请求无法实现</p></li><li><p style="line-height: 1.75em;">5xx：服务器端错误–服务器未能实现合法的请求</p></li></ul></ul><h3 style="line-height: 1.75em;">常见状态码：</h3><ol class=" list-paddingleft-2"><ol style="list-style-type: lower-alpha;" class=" list-paddingleft-2"><li><p style="line-height: 1.75em;">200 OK&nbsp;&nbsp;&nbsp;&nbsp;//客户端请求成功</p></li><li><p style="line-height: 1.75em;">400 Bad Request&nbsp;&nbsp;&nbsp;&nbsp;//客户端请求有语法错误，不能被服务器所理解</p></li><li><p style="line-height: 1.75em;">401 Unauthorized&nbsp;&nbsp;&nbsp;&nbsp;//请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</p></li><li><p style="line-height: 1.75em;">403 Forbidden&nbsp;&nbsp;&nbsp;&nbsp;//服务器收到请求，但是拒绝提供服务</p></li><li><p style="line-height: 1.75em;">404 Not Found&nbsp;&nbsp;&nbsp;&nbsp;//请求资源不存在，eg：输入了错误的URL</p></li><li><p style="line-height: 1.75em;">500 Internal Server Error&nbsp;&nbsp;&nbsp;&nbsp;//服务器发生不可预期的错误</p></li><li><p style="line-height: 1.75em;">503 
Server Unavailable&nbsp;&nbsp;&nbsp;&nbsp;//服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p></li></ol></ol><h3 style="line-height: 2em;"><strong>301、404、200、304等HTTP状态，代表什么意思?</strong><br/></h3><p style="line-height: 2em;">　　在网站建设的实际应用中，容易出现很多小小的失误，就像mysql当初优化不到位，影响整体网站的浏览效果一样，其实，网站的常规http状态码的表现也是一样，Google无法验证网站几种解决办法，提及到由于404状态页面设置不正常，导致了google管理员工具无法验证的情况，当然，影响的不仅仅是这一方面，影响的更是网站的整体浏览效果。因此，比较清楚详细的了解http状态码的具体含义，对于一个网站站长来说，这是很有必要俱备的网站制作基础条件。<br/>　　如果某项请求发送到您的服务器要求显示您网站上的某个网页(例如，用户通过浏览器访问您的网页或 Googlebot 抓取网页时)，服务器将会返回 HTTP 状态码响应请求。<br/>此状态码提供关于请求状态的信息，告诉 Googlebot 关于您的网站和请求的网页的信息。<br/><strong>一些常见的状态码为：</strong><br/><strong><em><span style="text-decoration: none;">&nbsp;&nbsp;&nbsp;&nbsp;200 - 服务器成功返回网页<br/>&nbsp;&nbsp;&nbsp;&nbsp;404 - 请求的网页不存在<br/>&nbsp;&nbsp;&nbsp;&nbsp;503 - 服务器超时</span></em></strong><br/>下面提供 HTTP 状态码的完整列表。点击链接可了解详情。您也可以访问 HTTP 状态码上的 W3C 页获取更多信息。</p><p style="line-height: 2em;"><span style="text-decoration: underline;"><strong>**1xx(**临时响应)</strong></span></p><p style="line-height: 2em;">表示临时响应并需要请求者继续执行操作的状态码。<strong><br/></strong></p><p style="line-height: 2em;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;100</strong>(继续)请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。<strong><br/></strong></p><p style="line-height: 2em;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;101</strong>(切换协议)请求者已要求服务器切换协议，服务器已确认并准备切换。<strong><br/></strong></p><p style="line-height: 2em;"><span style="text-decoration: underline;"><strong>2xx (成功)</strong></span><br/>表示成功处理了请求的状态码。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;200</strong>(成功)服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。<strong><br/></strong></p><p style="line-height: 2em;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;201</strong>(已创建)请求成功并且服务器创建了新的资源。<strong><br/></strong></p><p style="line-height: 2em;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;202</strong>(已接受)服务器已接受请求，但尚未处理。<strong><br/></strong></p><p style="line-height: 2em;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;203</strong>(非授权信息)服务器已成功处理了请求，但返回的信息可能来自另一来源。<strong><br/></strong></p><p style="line-height: 2em;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;204</strong>(无内容)服务器成功处理了请求，但没有返回任何内容。<strong><br/></strong></p><p style="line-height: 2em;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;205</strong>(重置内容)服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图(例如，清除表单内容以输入新内容)。<strong><br/></strong></p><p style="line-height: 2em;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;206</strong>(部分内容)服务器成功处理了部分 GET 请求。<br/><span style="text-decoration: underline;"><strong>**3xx **(重定向)</strong></span><br/>&nbsp;&nbsp;&nbsp;&nbsp;要完成请求，需要进一步操作。通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 
次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 
Googlebot 无法抓取的网址。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;300</strong>(多种选择)针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;301</strong>(永久移动)请求的网页已永久移动到新位置。服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;302</strong>(临时移动)服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应
 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 
某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;303</strong>(查看其他位置)请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;304</strong>(未修改)自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。<br/>如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应(称为 If-Modified-Since HTTP 标头)。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。</p>";s:7:"addtime";s:10:"1517887993";s:6:"remark";s:103:"一般状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:";s:5:"click";s:3:"319";s:3:"cid";s:2:"14";s:7:"blogpic";s:0:"";}i:1;a:8:{s:2:"id";s:2:"59";s:5:"title";s:28:"常见的HTTP状态码拆解";s:7:"content";s:7936:"<h2 data-line="0" class="line" style="line-height: 2em;">HTTP状态码</h2><p style="line-height: 1.75em;">状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p><ul class=" list-paddingleft-2"><li><p style="line-height: 1.75em;">1xx：指示信息–表示请求已接收，继续处理</p></li><li><p style="line-height: 1.75em;">2xx：成功–表示请求已被成功接收、理解、接受</p></li><li><p style="line-height: 1.75em;">3xx：重定向–要完成请求必须进行更进一步的操作</p></li><li><p style="line-height: 1.75em;">4xx：客户端错误–请求有语法错误或请求无法实现</p></li><li><p style="line-height: 1.75em;">5xx：服务器端错误–服务器未能实现合法的请求</p></li></ul><h3 style="line-height: 1.75em;">常见状态码：</h3><ol class=" list-paddingleft-2"><li><p style="line-height: 1.75em;">200 OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //客户端请求成功</p></li><li><p style="line-height: 1.75em;">400 Bad Request&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //客户端请求有语法错误，不能被服务器所理解</p></li><li><p style="line-height: 1.75em;">401 Unauthorized&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</p></li><li><p style="line-height: 1.75em;">403 Forbidden&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //服务器收到请求，但是拒绝提供服务</p></li><li><p style="line-height: 1.75em;">404 Not Found &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp;&nbsp; //请求资源不存在，eg：输入了错误的URL</p></li><li><p style="line-height: 1.75em;">500 Internal Server Error &nbsp; &nbsp; //服务器发生不可预期的错误</p></li><li><p style="line-height: 1.75em;">503 
Server Unavailable &nbsp; &nbsp; &nbsp; //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p></li></ol><h3 style="line-height: 2em;"><strong>301、404、200、304等HTTP状态，代表什么意思?</strong><br/></h3><p style="line-height: 2em;">　　在网站建设的实际应用中，容易出现很多小小的失误，就像mysql当初优化不到位，影响整体网站的浏览效果一样，其实，网站的常规http状态码的表现也是一样，Google无法验证网站几种解决办法，提及到由于404状态页面设置不正常，导致了google管理员工具无法验证的情况，当然，影响的不仅仅是这一方面，影响的更是网站的整体浏览效果。因此，比较清楚详细的了解http状态码的具体含义，对于一个网站站长来说，这是很有必要俱备的网站制作基础条件。<br/>　　如果某项请求发送到您的服务器要求显示您网站上的某个网页(例如，用户通过浏览器访问您的网页或 Googlebot 抓取网页时)，服务器将会返回 HTTP 状态码响应请求。<br/>此状态码提供关于请求状态的信息，告诉 Googlebot 关于您的网站和请求的网页的信息。<br/><strong>一些常见的状态码为：</strong><br/>　　<strong><em><span style="text-decoration: none;">200 - 服务器成功返回网页<br/>　　404 - 请求的网页不存在<br/>　　503 - 服务器超时</span></em></strong><br/>下面提供 HTTP 状态码的完整列表。点击链接可了解详情。您也可以访问 HTTP 状态码上的 W3C 页获取更多信息。<br/>　　**1xx(**临时响应)<br/>&nbsp;&nbsp;&nbsp;&nbsp;表示临时响应并需要请求者继续执行操作的状态码。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100</strong>(继续)请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;101</strong>(切换协议)请求者已要求服务器切换协议，服务器已确认并准备切换。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2xx</strong> (成功)<br/>&nbsp;&nbsp;&nbsp;&nbsp;表示成功处理了请求的状态码。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;200</strong>(成功)服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;201</strong>(已创建)请求成功并且服务器创建了新的资源。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;202</strong>(已接受)服务器已接受请求，但尚未处理。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;203</strong>(非授权信息)服务器已成功处理了请求，但返回的信息可能来自另一来源。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;204</strong>(无内容)服务器成功处理了请求，但没有返回任何内容。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;205</strong>(重置内容)服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图(例如，清除表单内容以输入新内容)。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;206</strong>(部分内容)服务器成功处理了部分 GET 请求。<br/>　　**3xx **(重定向)<br/>要完成请求，需要进一步操作。通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 
次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 
Googlebot 无法抓取的网址。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 300</strong>(多种选择)针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 301</strong>(永久移动)请求的网页已永久移动到新位置。服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;302</strong>(临时移动)服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应
 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 
某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;303</strong>(查看其他位置)请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。<br/><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;304</strong>(未修改)自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。<br/>如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应(称为 If-Modified-Since HTTP 标头)。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。</p>";s:7:"addtime";s:10:"1517887573";s:6:"remark";s:103:"一般状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:";s:5:"click";s:1:"0";s:3:"cid";s:1:"0";s:7:"blogpic";s:0:"";}i:2;a:8:{s:2:"id";s:2:"58";s:5:"title";s:56:"linux每天定时备份数据库并删除十天前数据";s:7:"content";s:3000:"<p style="line-height: 2em;"><span style="font-family: 宋体, SimSun; font-size: 14px;">如何做到每天定时备份数据库，这里我们需要用到Linux的定时任务，利用Linux的crondtab 命令。下面我们来看详细步骤：</span></p><h3 style="line-height: 2em;"><span style="font-family: 宋体, SimSun; color: rgb(0, 0, 0);">一：写好shell脚本&nbsp;&nbsp; mysqlbak.sh</span></h3><p style="line-height: 2em;"><span style="color: rgb(0, 112, 192); font-family: 宋体, SimSun; font-size: 14px;">#!/bin/sh<br/>mysqldump -uroot -pmysqlroot xhblt | gzip &gt; /mysqlbak/`date &#39;+%Y-%m-%d_%H:%M:%S&#39;`.sql.gz<br/>find /mysqlbak/ -mtime +10 -name &quot;*.sql.gz&quot; -exec rm -rf {} \;</span></p><h4 style="line-height: 2em;"><span style="font-family: 宋体, SimSun; color: rgb(0, 0, 0);">脚本解析：</span><span style="font-family: 宋体, SimSun;"><span style="font-family: 宋体, SimSun; color: rgb(0, 176, 240);"></span><span style="font-family: 宋体, SimSun; color: rgb(0, 0, 0);"></span></span></h4><p style="line-height: 2em;"><span style="color: rgb(0, 0, 0); font-family: 宋体, SimSun; font-size: 14px;">（1）mysqldump -uroot -pmysqlroot xhblt | gzip &gt; /mysqlbak/`date &#39;+%Y-%m-%d_%H:%M:%S&#39;`.sql.gz<br/>&nbsp;&nbsp; &nbsp;此举含义为下载数据库文件，将数据库文件以”年-月-日-时-分-秒.sql.gz”的名称存在根目录下的mysqlbak文件夹中,数据库的登录备份信息为：（用户名:root&nbsp; 密码：mysqlroot 需要备份数据库名称为：xhblt）<br/>（2）find /mysqlbak/ -mtime +10 -name &quot;*.sql.gz&quot; -exec rm -rf {} \;<br/>&nbsp;&nbsp; &nbsp;含义为：找到根目录下mysqlbak文件夹中的数据然后删除10天前的数据</span><span style="color: rgb(0, 0, 0); font-family: 宋体, SimSun;"><br/></span></p><h3 style="line-height: 2em;"><span style="font-family: 宋体, SimSun; color: rgb(0, 0, 0);">二：目录创建以及文件上传</span></h3><p style="line-height: 2em;"><span style="font-family: 宋体, SimSun; font-size: 14px; color: rgb(0, 0, 0);">（1）在根目录下创建文件夹&nbsp; mysqlbak作为备份目录，目录权为777<br/>&nbsp;&nbsp; &nbsp;mkdir /mysqlbak;<br/>&nbsp;&nbsp; &nbsp;chmod 777 /mysqlbak;<br/>（2）文件上传<br/>&nbsp;&nbsp; &nbsp;将写好的shell脚本放在 /etc 目录下，并且赋予权限 777<br/>&nbsp;&nbsp; &nbsp;chmod 777 /etc/mysqlbak.sh</span></p><h3 style="line-height: 2em;"><span style="font-family: 宋体, SimSun; color: rgb(0, 0, 0);">三：加入定时任务</span></h3><p style="line-height: 2em;"><span style="font-family: 宋体, SimSun; font-size: 14px; color: rgb(0, 0, 0);">（1）输入 “ crontab –e ” 命令加入<br/>&nbsp;&nbsp; &nbsp;0 3 * * * /etc/mysqlbak.sh&nbsp;&nbsp; //每天凌晨三点执行shell文件<br/>&nbsp;&nbsp; &nbsp;然后”:wq!”保存退出<br/>（2）输入”service crond restart” 重启定时服务</span><span style="font-family: 宋体, SimSun;"><br/></span></p>";s:7:"addtime";s:10:"1516931033";s:6:"remark";s:139:"要实现每天定时备份数据库，我们需要用到Linux的定时任务。利用Linux的crondtab 命令下面我们来看详细步骤";s:5:"click";s:3:"119";s:3:"cid";s:2:"14";s:7:"blogpic";s:0:"";}i:3;a:8:{s:2:"id";s:2:"57";s:5:"title";s:46:"SyntaxError: invalid regular expression flag c";s:7:"content";s:1907:"<p style="line-height: 1.75em;"><span style="font-size: 16px;">当你Javascript提示错误：SyntaxError: invalid regular expression flag c，一般是因为正则表达式错误而产生的错误。首先检查你的的Javascript的正则表达式是否书写错误，如果没有错误那么有可能是下面这种原因造成的。</span></p><p style="line-height: 1.75em;"><span style="font-size: 16px;">定义json格式错误：</span></p><p style="line-height: 1.75em;"><span style="font-size: 16px;">没错就是json格式定义错误，本人被折磨了两天才发现的，首先来看错误的json格式<span style="font-size: 18px;"><br/></span></span></p><p style="line-height: 1.75em;"><span style="font-size: 16px;">{url:url, preview_url:url, filepath:url, id:id}</span></p><p style="line-height: 1.75em;"><span style="font-size: 16px;">咋一看没什么错误，但是标准的json的键名应该带有&#39;号的，如果没有Javascript会将键名当作变量处理，所以当你把json添加到数组或者其他的操作时就会报SyntaxError: invalid regular expression flag c了，所以大家书写代码时一定要规范。正确的json格式应该为：</span></p><p style="line-height: 1.75em;"><span style="font-size: 16px;"></span></p><p style="line-height: 1.75em;"><span style="font-size: 16px;"><span style="font-size: 16px; font-family: 宋体, SimSun;"></span><span style="font-size: 18px;">{&#39;url&#39;:url, &#39;preview_url&#39;:url, &#39;filepath&#39;:url, &#39;id&#39;:id}</span></span></p><p style="line-height: 1.75em;"><span style="font-size: 16px;">当然也有其他原因造成，如果大家发现可以分享给我，好了本文到此结束，希望可以帮到大家</span><span style="font-size: 16px;"></span><br/></p><p><span style="font-size: 18px;"></span><br/></p><p><span style="font-size: 18px;"></span></p><p><br/></p><p><br/></p><p><br/></p>";s:7:"addtime";s:10:"1516004628";s:6:"remark";s:182:"Javascript报SyntaxError: invalid regular expression flag c一般是因为正则表达式错误而产生的错误，不过有时候也会因为一些其他的原因造成这种错误";s:5:"click";s:3:"157";s:3:"cid";s:1:"6";s:7:"blogpic";s:0:"";}i:4;a:8:{s:2:"id";s:2:"56";s:5:"title";s:42:"如何查看,修改，删除Mysql的索引";s:7:"content";s:11356:"<h3 style="line-height: 1.75em;"><strong>1．索引作用</strong></h3><p style="line-height: 1.75em;">数据库利用各种各样的快速定位技术，能够大大提高查询效率。特别是当数据量非常大，查询涉及多个表时，使用索引往往能使查询速度加快成千上万倍。</p><p style="line-height: 1.75em;">例如：</p><p style="line-height: 1.75em;">有3个未索引的表t1、t2、t3，分别只包含列c1、c2、c3，每个表分别含有1000行数据组成，指为1～1000的数值，查找对应值相等行的查询如下所示。</p><p style="line-height: 1.75em;">SELECT c1,c2,c3 FROM t1,t2,t3 WHERE c1=c2 AND c1=c3<br/>此查询结果应该为1000行，每行包含3个相等的值。在无索引的情况下处理此查询，必须寻找3个表所有的组合，以便得出与WHERE子句相配的那些行。而可能的组合数目为1000×1000×1000（十亿），显然查询将会非常慢。</p><p style="line-height: 1.75em;">如果对每个表进行索引，就能极大地加速查询进程。利用索引的查询处理如下。</p><p style="line-height: 1.75em;">（1）从表t1中选择第一行，查看此行所包含的数据。<br/>（2）使用表t2上的索引，直接定位t2中与t1的值匹配的行。类似，利用表t3上的索引，直接定位t3中与来自t1的值匹配的行。<br/>（3）扫描表t1的下一行并重复前面的过程，直到遍历t1中所有的行。</p><p style="line-height: 1.75em;">在此情形下，仍然对表t1执行了一个完全扫描，但能够在表t2和t3上进行索引查找直接取出这些表中的行，比未用索引时要快一百万倍。<br/>利用索引，MySQL加速了WHERE子句满足条件行的搜索，而在多表连接查询时，在执行连接时加快了与其他表中的行匹配的速度。</p><h3 style="line-height: 1.75em;"><strong>2.&nbsp; 创建索引</strong></h3><p style="line-height: 1.75em;">在执行CREATE TABLE语句时可以创建索引，也可以单独用CREATE INDEX或ALTER TABLE来为表增加索引。</p><p style="line-height: 1.75em;">1．ALTER TABLE</p><p style="line-height: 1.75em;">ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p><table cellspacing="0" cellpadding="0"><tbody><tr class="firstRow"><td class="gutter"><p style="line-height: 1.75em;">1</p><p style="line-height: 1.75em;">2</p><p style="line-height: 1.75em;">3</p></td><td class="code"><p style="line-height: 1.75em;"><code class="sql keyword">ALTER</code> <code class="sql keyword">TABLE</code> <code class="sql plain">table_name </code><code class="sql keyword">ADD</code> <code class="sql keyword">INDEX</code> <code class="sql plain">index_name (column_list)</code></p><p style="line-height: 1.75em;"><code class="sql keyword">ALTER</code> <code class="sql keyword">TABLE</code> <code class="sql plain">table_name </code><code class="sql keyword">ADD</code> <code class="sql keyword">UNIQUE</code> <code class="sql plain">(column_list)</code></p><p style="line-height: 1.75em;"><code class="sql keyword">ALTER</code> <code class="sql keyword">TABLE</code> <code class="sql plain">table_name </code><code class="sql keyword">ADD</code> <code class="sql keyword">PRIMARY</code> <code class="sql keyword">KEY</code> <code class="sql plain">(column_list)</code></p></td></tr></tbody></table><p style="line-height: 1.75em;">其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。索引名index_name可选，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER
 TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p><p style="line-height: 1.75em;">2．CREATE INDEX</p><p style="line-height: 1.75em;">CREATE INDEX可对表增加普通索引或UNIQUE索引。</p><table cellspacing="0" cellpadding="0"><tbody><tr class="firstRow"><td class="gutter"><p style="line-height: 1.75em;">1</p><p style="line-height: 1.75em;">2</p></td><td class="code"><p style="line-height: 1.75em;"><code class="sql keyword">CREATE</code> <code class="sql keyword">INDEX</code> <code class="sql plain">index_name </code><code class="sql keyword">ON</code> <code class="sql plain">table_name (column_list)</code></p><p style="line-height: 1.75em;"><code class="sql keyword">CREATE</code> <code class="sql keyword">UNIQUE</code> <code class="sql keyword">INDEX</code> <code class="sql plain">index_name </code><code class="sql keyword">ON</code> <code class="sql plain">table_name (column_list)</code></p></td></tr></tbody></table><p style="line-height: 1.75em;">table_name、index_name和column_list具有与ALTER TABLE语句中相同的含义，索引名不可选。另外，不能用CREATE INDEX语句创建PRIMARY KEY索引。</p><h3 style="line-height: 1.75em;"><strong>3．索引类型</strong></h3><p style="line-height: 1.75em;">在创建索引时，可以规定索引能否包含重复值。如果不包含，则索引应该创建为PRIMARY KEY或UNIQUE索引。对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。</p><p style="line-height: 1.75em;">PRIMARY KEY索引和UNIQUE索引非常类似。事实上，PRIMARY KEY索引仅是一个具有名称PRIMARY的UNIQUE索引。这表示一个表只能包含一个PRIMARY KEY，因为一个表中不可能具有两个同名的索引。</p><p style="line-height: 1.75em;">下面的SQL语句对students表在sid上添加PRIMARY KEY索引。代码如下:</p><p style="line-height: 1.75em;">ALTER TABLE students ADD PRIMARY KEY (sid)</p><h3 style="line-height: 1.75em;"><strong>4.&nbsp; 删除索引</strong></h3><p style="line-height: 1.75em;">可利用ALTER TABLE或DROP INDEX语句来删除索引。类似于CREATE INDEX语句，DROP INDEX可以在ALTER TABLE内部作为一条语句处理，语法如下。</p><table cellspacing="0" cellpadding="0"><tbody><tr class="firstRow"><td class="gutter"><p style="line-height: 1.75em;">1</p><p style="line-height: 1.75em;">2</p><p style="line-height: 1.75em;">3</p></td><td class="code"><p style="line-height: 1.75em;"><code class="sql keyword">DROP</code> <code class="sql keyword">INDEX</code> <code class="sql plain">index_name </code><code class="sql keyword">ON</code> <code class="sql plain">talbe_name</code></p><p style="line-height: 1.75em;"><code class="sql keyword">ALTER</code> <code class="sql keyword">TABLE</code> <code class="sql plain">table_name </code><code class="sql keyword">DROP</code> <code class="sql keyword">INDEX</code> <code class="sql plain">index_name</code></p><p style="line-height: 1.75em;"><code class="sql keyword">ALTER</code> <code class="sql keyword">TABLE</code> <code class="sql plain">table_name </code><code class="sql keyword">DROP</code> <code class="sql keyword">PRIMARY</code> <code class="sql keyword">KEY</code></p></td></tr></tbody></table><p style="line-height: 1.75em;">其中，前两条语句是等价的，删除掉table_name中的索引index_name。<br/>第3条语句只在删除PRIMARY KEY索引时使用，因为一个表只可能有一个PRIMARY KEY索引，因此不需要指定索引名。如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。<br/>如果从表中删除了某列，则索引会受到影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。</p><h3 style="line-height: 1.75em;"><strong>5．查看索引</strong></h3><table cellspacing="0" cellpadding="0"><tbody><tr class="firstRow"><td class="gutter"><p style="line-height: 1.75em;">1</p><p style="line-height: 1.75em;">2</p></td><td class="code" style="word-break: break-all;"><p style="line-height: 1.75em;"><code class="sql plain">mysql&gt; show </code><code class="sql keyword">index</code> <code class="sql keyword">from</code> <code class="sql plain">tblname;</code></p><p style="line-height: 1.75em;"><code class="sql plain">mysql&gt; show keys </code><code class="sql keyword">from</code> <code class="sql plain">tblname;</code></p></td></tr></tbody></table><p style="line-height: 1.75em;">显示结果: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p style="line-height: 1.75em;">Table:&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tb_push&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;· Table&nbsp;&nbsp; &nbsp;表的名称<br/>Non_unique:&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; · Non_unique&nbsp;&nbsp; &nbsp;如果索引不能包括重复词，则为0。如果可以，则为1 &nbsp;&nbsp;&nbsp; <br/>Key_name:&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;uid&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; · Key_name&nbsp;&nbsp; &nbsp;索引的名称。<br/>Seq_in_index:&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;1&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; · Seq_in_index&nbsp;&nbsp; &nbsp;索引中的列序列号，从1开始。<br/>Column_name:&nbsp;&nbsp; &nbsp;&nbsp; uid&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; · Column_name&nbsp;&nbsp; &nbsp;列名称。<br/>Collation:&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; A&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; · Collation&nbsp;&nbsp; &nbsp;列以什么方式存储在索引中。在MySQL中，有值‘A&#39;（升序）或NULL（无分类）<br/>Cardinality:&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; · Cardinality&nbsp;&nbsp; &nbsp;索引中唯一值的数目的估计值。通过运行ANALYZE TABLE或myisamchk -a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL使用该索引的机会就越大。<br/>Sub_part:&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; · Sub_part&nbsp;&nbsp; &nbsp;如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL。<br/>Packed:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; · Packed&nbsp;&nbsp; &nbsp;指示关键字如何被压缩。如果没有被压缩，则为NULL。<br/>Null:&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; · Null&nbsp;&nbsp; &nbsp;如果列含有NULL，则含有YES。如果没有，则该列含有NO。<br/>Index_type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BTREE&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; · Index_type&nbsp;&nbsp; &nbsp;用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）<br/>Comment:<br/>Index_comment:</p><p><br/></p><p><br/><br/></p><p><br/></p>";s:7:"addtime";s:10:"1515571503";s:6:"remark";s:169:"本篇文章主要讲解下Mysql的索引的查看，删除，修改方法。结合例子详细分析，mysql索引的使用技巧，希望能帮助到有需要的朋友";s:5:"click";s:2:"46";s:3:"cid";s:2:"13";s:7:"blogpic";s:0:"";}}
?>